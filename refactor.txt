================================================================================
REFACTOR PLAYBOOK
================================================================================
Project: dev_app
A step-by-step guide for maintaining code quality.

================================================================================
1. DEAD CODE ANALYSIS
================================================================================

**Goal:** Remove unused code to reduce maintenance burden.

**Steps:**
1.1. **JavaScript Dead Code**
     - Search for .js files with 0 references in templates
     - grep -r "filename.js" templates/ → if 0 hits, candidate for removal
     - Check for functions defined but never called

1.2. **Python Dead Code**
     - Search for views not in urls.py
     - Search for functions with 0 call sites
     - Run: grep -r "def function_name" → then grep -r "function_name("

1.3. **Unused Imports**
     - Run: pylint --disable=all --enable=W0611 core/
     - Or use IDE "Optimize Imports" feature

1.4. **Orphaned Templates**
     - Search for templates not referenced in views or other templates
     - grep -r "template_name.html" views/ templates/

**Verification:**
- python manage.py check
- python manage.py runserver (no import errors)

================================================================================
2. DUPLICATION ANALYSIS
================================================================================

**Goal:** Consolidate repeated code into shared modules.

**Steps:**
2.1. **Identify Duplicate Functions**
     - Search for common function names across files:
       grep -r "function getCookie" static/
       grep -r "def get_project" views/
     
2.2. **Create/Update Shared Modules**
     - JS: core/static/core/js/utils.js
     - Python: core/services/*.py

2.3. **Consolidate Duplicates**
     - Move function to shared module
     - Update all call sites to use shared version
     - Remove old definitions

2.4. **Verify No Remaining Duplicates**
     - Re-run searches from step 2.1

**Verification:**
- Test all affected features
- python manage.py check

================================================================================
3. DJANGO BEST PRACTICES
================================================================================

**Goal:** Follow Django conventions for maintainability and performance.

**Steps:**
3.1. **N+1 Query Prevention**
     - Add select_related() for ForeignKey access
     - Add prefetch_related() for reverse relations
     - Use django-debug-toolbar to identify query counts

3.2. **Model Optimization**
     - Add indexes to frequently filtered fields
     - Add ordering in Meta class where appropriate
     - Add constraints for data integrity

3.3. **View Patterns**
     - Use Class-Based Views for standard CRUD
     - Move form validation to forms.py
     - Use Django messages framework

3.4. **URL Organization**
     - Use app namespaces
     - Use path converters (<int:pk>)

**Verification:**
- python manage.py check
- python manage.py check --deploy

================================================================================
4. UTILS.JS BEST PRACTICE
================================================================================

**Goal:** Centralize reusable JS functions in Utils namespace.

**Steps:**
4.1. **Audit Existing JS Files**
     - Search for functions that duplicate utils.js:
       grep -r "function getCookie\|function formatMoney\|function escapeHtml" static/

4.2. **Identify Extraction Candidates**
     - Look for functions repeated across 2+ files
     - Look for generic utility patterns (formatting, validation, AJAX helpers)

4.3. **Add to utils.js**
     - Add function with JSDoc comment
     - Add to Utils namespace object
     - Do NOT add separate window.* assignments

4.4. **Update Call Sites**
     - Replace local function calls with Utils.functionName()
     - Remove old function definitions

4.5. **Verify Utils Namespace**
     - All functions accessible via Utils.* only
     - No duplicate window.* globals

**Verification:**
- Browser console: typeof Utils.functionName === 'function'
- Test affected features

================================================================================
5. SECURITY AUDIT
================================================================================

**Goal:** Prevent common vulnerabilities.

**Steps:**
5.1. **SQL Injection**
     - Search for raw() queries → ensure parameterized
     - Search for .extra() → prefer ORM

5.2. **XSS Prevention**
     - Search for |safe filter → ensure escaped first
     - Use |escapejs for JS strings

5.3. **CSRF Protection**
     - All POST forms have {% csrf_token %} or AJAX sends X-CSRFToken

5.4. **Secrets Management**
     - No hardcoded API keys/passwords
     - All secrets in environment variables

5.5. **Authentication**
     - Views require @login_required where appropriate
     - API endpoints validate permissions

**Verification:**
- python manage.py check --deploy
- grep -r "API_KEY\|SECRET\|PASSWORD" --include="*.py" (should only be in settings)

================================================================================
6. PERFORMANCE REVIEW
================================================================================

**Goal:** Optimize slow operations.

**Steps:**
6.1. **Database**
     - Add indexes for common WHERE clauses
     - Use EXPLAIN ANALYZE on slow queries
     - Implement pagination for large lists

6.2. **Frontend**
     - Minify JS/CSS for production
     - Lazy load images and large data
     - Use browser caching headers

6.3. **Django**
     - Enable template caching
     - Use @cache_page for expensive views
     - Optimize queryset evaluation

**Tools:**
- django-debug-toolbar
- Chrome DevTools Performance tab
- Lighthouse audit

================================================================================
7. DOCUMENTATION UPDATE
================================================================================

**Goal:** Keep documentation current and useful.

**Steps:**
7.1. **File Headers**
     - Each .py file has docstring explaining purpose
     - Each .js file has comment block at top

7.2. **Function Documentation**
     - Public functions have docstrings/JSDoc
     - Parameters and return values documented

7.3. **Project Docs**
     - README.md current with setup instructions
     - Deployment guides accurate
     - Architecture decisions documented

**Key Docs to Maintain:**
- README.md
- DEPLOYMENT_GUIDE.md
- MODEL_SERVICE_MAPPING.md

================================================================================
QUICK REFERENCE
================================================================================

**Common Commands:**
- python manage.py check
- python manage.py check --deploy
- grep -r "pattern" directory/

**Key Files:**
- utils.js: core/static/core/js/utils.js
- Services: core/services/*.py
- Views: core/views/*.py

**Principles:**
- DRY: Don't Repeat Yourself
- Single Responsibility: One purpose per function/file
- Fail Fast: Validate early, error with context
