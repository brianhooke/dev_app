PROJECT MANAGEMENT APP REFACTOR - SUPERPROMPT

================================================================================
OVERVIEW
================================================================================

Transform the current construction-focused project management app into a 
modular, extensible platform that supports multiple project types while 
maintaining a shared core of common functionality.

Current State: Monolithic "core" app with all logic, templates, and static 
assets in one place.

Target State: Modular architecture with:
- A "core" app containing PROJECT_TYPE-agnostic functionality
- Multiple PROJECT_TYPE apps (general, development, construction, precast, pods)
- SERVICE modules encapsulating business logic for reusability
- Clear separation of concerns with predictable override patterns

================================================================================
ARCHITECTURE PRINCIPLES
================================================================================

1. PROJECT_TYPE Apps
   - Each PROJECT_TYPE is a separate Django app
   - Apps: core, general, development, construction, precast, pods
   - "core" contains shared/common functionality used across all project types
   - Other apps contain PROJECT_TYPE-specific models, views, templates, logic

2. SERVICE Modules
   - Business logic extracted from views into reusable SERVICE modules
   - SERVICEs: quotes, bills, pos, invoices, variations, suppliers, 
     order_book, documents
   - Each app has a services/ directory containing relevant SERVICEs
   - Core SERVICEs provide base functionality; PROJECT_TYPE apps can 
     extend/override

3. URL Routing & Namespacing
   - dev_app/urls.py includes core.urls (always)
   - Conditionally includes PROJECT_TYPE app URLs based on active project type
   - Each app uses URL namespaces (app_name) to avoid collisions
   - Example: reverse("core:invoices_list") vs reverse("construction:invoices_list")

4. Templates & Static Assets
   - Namespaced folder structure:
     - core/templates/core/...
     - construction/templates/construction/...
   - Use Django template inheritance for overrides
   - Static assets follow same pattern:
     - core/static/core/js/...
     - construction/static/construction/js/...
   - Conditional includes based on PROJECT_TYPE resolver

5. PROJECT_TYPE Resolver
   - Mechanism to determine active PROJECT_TYPE for a request/project/tenant
   - Options:
     - Field on Project model (e.g., project.project_type)
     - Organization/Tenant preference
     - Session or user preference
   - Middleware or helper attaches request.project_type
   - Views and templates use this to load appropriate behavior/assets

6. Models
   - Shared entities (Project, Contact, Invoice, etc.) in core.models
   - PROJECT_TYPE-specific entities in respective app models
   - Use ForeignKey to reference core models from PROJECT_TYPE apps
   - Keep boundaries clean: core must NOT import from PROJECT_TYPE apps

================================================================================
TASK BREAKDOWN
================================================================================

TASK 1: Create App Structure for All PROJECT_TYPEs
---------------------------------------------------
Goal: Scaffold all PROJECT_TYPE apps with standard Django structure

Steps:
1.1. For each PROJECT_TYPE (general, development, construction, precast, pods):
     - Run: django-admin startapp <project_type>
     - Verify standard files created: __init__.py, apps.py, models.py, 
       views.py, admin.py, tests.py

1.2. Create standard directories in each PROJECT_TYPE app:
     - migrations/
     - services/
     - templates/<project_type>/
     - static/<project_type>/
       - js/
       - css/
       - images/

1.3. Update each app's apps.py:
     - Set appropriate AppConfig class name (e.g., GeneralConfig, 
       ConstructionConfig)
     - Ensure name = '<project_type>' is correct

1.4. Create __init__.py in each services/ directory

1.5. Verify core/ app already has the same structure from previous work

Deliverable: All PROJECT_TYPE apps exist with proper folder structure


TASK 2: Create SERVICE Module Stubs
------------------------------------
Goal: Create empty SERVICE module files in each app's services/ directory

Steps:
2.1. For each PROJECT_TYPE app (core, general, development, construction, 
     precast, pods):
     - Create services/ directory if not exists
     - Create __init__.py in services/

2.2. Create stub files for each SERVICE in core/services/:
     - quotes.py
     - bills.py
     - pos.py
     - invoices.py
     - variations.py
     - suppliers.py
     - order_book.py
     - documents.py

2.3. Add docstring to each stub explaining its purpose:
     """
     <SERVICE_NAME> service module.
     
     Contains business logic for <SERVICE_NAME> operations that is 
     PROJECT_TYPE-agnostic and reusable across all project types.
     """

2.4. For PROJECT_TYPE apps (general, development, construction, precast, pods):
     - Create the same SERVICE files only if that PROJECT_TYPE needs 
       specific logic for that SERVICE
     - Add docstring explaining PROJECT_TYPE-specific behavior
     - Initially, most can be empty; populate as we migrate logic

Deliverable: SERVICE module structure in place across all apps


TASK 3: Convert core/views.py to Package
-----------------------------------------
Goal: Split monolithic core/views.py into modular package while maintaining 
      backward compatibility

Steps:
3.1. Create core/views/ directory

3.2. Split core/views.py into logical modules:
     - base.py: PROJECT_TYPE-agnostic views (homepage, common utilities)
     - api.py: AJAX/JSON endpoints
     - mixins.py: Reusable CBV mixins and helpers
     - <service>_views.py: One per major SERVICE if views are large
       (e.g., invoices_views.py, quotes_views.py)

3.3. Create core/views/__init__.py that re-exports all views:
     from .base import *
     from .api import *
     from .mixins import *
     # ... etc
     
     This ensures existing imports like "from core.views import some_view" 
     continue to work

3.4. Move view functions/classes to appropriate modules based on their 
     SERVICE domain

3.5. Update imports within the views package to reference sibling modules

3.6. Test that all URL patterns in core/urls.py still resolve correctly

3.7. Commit as "move-only" commit to preserve git blame

Deliverable: core/views.py replaced with core/views/ package; all imports working


TASK 4: Extract Business Logic into SERVICE Modules
----------------------------------------------------
Goal: Move business logic from views into SERVICE modules for reusability

Steps:
4.1. Audit core/views/ modules to identify business logic vs presentation logic
     - Business logic: calculations, data aggregation, queries, validations
     - Presentation logic: rendering templates, handling request/response

4.2. For each SERVICE (quotes, bills, pos, invoices, variations, suppliers, 
     order_book, documents):
     - Identify related business logic in views
     - Create functions/classes in core/services/<service>.py
     - Move logic from views to SERVICE modules
     - Update views to call SERVICE functions

4.3. Follow patterns:
     - SERVICE functions take explicit parameters (not request objects)
     - Return data structures (dicts, querysets, model instances)
     - Views remain thin: handle request, call SERVICE, render response

4.4. Add docstrings and type hints to SERVICE functions

4.5. Write unit tests for SERVICE functions (independent of views/requests)

4.6. Update views incrementally, testing after each SERVICE extraction

Deliverable: Core business logic extracted to core/services/; views are thin 
             controllers


TASK 5: Set Up URL Routing with Namespaces
-------------------------------------------
Goal: Configure URL routing for all PROJECT_TYPE apps with proper namespacing

Steps:
5.1. Create urls.py in each PROJECT_TYPE app (general, development, 
     construction, precast, pods)

5.2. In each app's urls.py:
     - Set app_name = "<project_type>" for namespace
     - Define urlpatterns for PROJECT_TYPE-specific routes
     - Import views from the app's views.py

5.3. Update dev_app/urls.py:
     - Always include core.urls with namespace
     - Add conditional includes for PROJECT_TYPE apps (initially can include 
       all; refine with resolver later)
     - Example:
       urlpatterns = [
           path("", include(("core.urls", "core"), namespace="core")),
           path("general/", include(("general.urls", "general"), 
                namespace="general")),
           path("construction/", include(("construction.urls", "construction"), 
                namespace="construction")),
           # ... etc
       ]

5.4. Update templates to use namespaced URL reversing:
     - {% url 'core:invoices_list' %} instead of {% url 'invoices_list' %}

5.5. Update views to use namespaced reverse():
     - reverse("core:invoices_list") instead of reverse("invoices_list")

5.6. Test all URL patterns resolve correctly

Deliverable: All apps have namespaced URLs; routing configured in dev_app/urls.py


TASK 6: Namespace Templates and Static Assets
----------------------------------------------
Goal: Organize templates and static assets with namespacing for predictable 
      overrides

Steps:
6.1. Templates:
     - Ensure core/templates/core/ structure exists
     - Move existing templates under core/templates/core/
     - Create base templates in core/templates/core/ (e.g., base.html, 
       master.html)
     - For each PROJECT_TYPE app, create templates/<project_type>/ directory
     - Use {% extends "core/base.html" %} in PROJECT_TYPE templates
     - Override specific blocks where PROJECT_TYPE needs custom behavior

6.2. Static Assets:
     - Ensure core/static/core/ structure exists
     - Move existing static files under core/static/core/
     - Organize by type: js/, css/, images/
     - For each PROJECT_TYPE app, create static/<project_type>/ with same 
       structure
     - Create PROJECT_TYPE-specific JS/CSS files as needed

6.3. Update template {% load static %} and {% static %} tags to use namespaced 
     paths:
     - {% static 'core/js/invoices.js' %}
     - {% static 'construction/js/hc_claims.js' %}

6.4. Update views to reference namespaced template paths:
     - render(request, "core/invoices/list.html", context)
     - render(request, "construction/claims/list.html", context)

6.5. Run collectstatic and verify static files are found correctly

6.6. Test that templates render and static assets load

Deliverable: All templates and static assets namespaced; overrides working


TASK 7: Implement PROJECT_TYPE Resolver
----------------------------------------
Goal: Create mechanism to determine and use active PROJECT_TYPE

Steps:
7.1. Design PROJECT_TYPE resolution strategy:
     - Option A: Add project_type field to Project model
     - Option B: Organization/Tenant model with project_type preference
     - Option C: Session-based or user preference
     - Decision: Start with Option A (field on Project model)

7.2. Add project_type field to Project model:
     - CharField with choices: 'general', 'development', 'construction', 
       'precast', 'pods'
     - Default: 'general'
     - Create and apply migration

7.3. Create middleware or context processor:
     - Determine project_type from current request context (e.g., URL param, 
       session, or project lookup)
     - Attach to request: request.project_type
     - Make available in templates: {{ request.project_type }}

7.4. Update views to use request.project_type:
     - Conditionally load PROJECT_TYPE-specific SERVICEs
     - Choose template paths based on PROJECT_TYPE
     - Example:
       if request.project_type == 'construction':
           return render(request, "construction/invoices/list.html", context)
       return render(request, "core/invoices/list.html", context)

7.5. Update dev_app/urls.py to conditionally include PROJECT_TYPE URLs:
     - Use resolver to determine active PROJECT_TYPE
     - Include only relevant app URLs (or mount all with prefixes)

7.6. Add PROJECT_TYPE selector UI (e.g., dropdown in navbar) if needed

7.7. Test switching between PROJECT_TYPEs and verify correct behavior

Deliverable: PROJECT_TYPE resolver in place; request.project_type available 
             throughout app


TASK 8: Migrate PROJECT_TYPE-Specific Logic
--------------------------------------------
Goal: Move PROJECT_TYPE-specific code from core to respective apps

Steps:
8.1. Audit core/ for PROJECT_TYPE-specific logic:
     - Search for construction-specific terms: "HC claims", "progress claims", 
       "variations", "precast", etc.
     - Identify models, views, templates, SERVICEs tied to specific 
       PROJECT_TYPEs

8.2. For each PROJECT_TYPE-specific piece:
     - Determine target app (construction, precast, etc.)
     - Move models to <project_type>/models.py
     - Move views to <project_type>/views.py
     - Move templates to <project_type>/templates/<project_type>/
     - Move static assets to <project_type>/static/<project_type>/
     - Move SERVICE logic to <project_type>/services/

8.3. Update imports and references:
     - Change "from core.models import X" to "from construction.models import X"
     - Update ForeignKey references if needed
     - Update URL patterns and namespaces

8.4. Create migrations for model moves:
     - If moving models between apps, use db_table to preserve table names
     - Or create data migrations to move data if renaming tables

8.5. Update admin.py in each app to register PROJECT_TYPE-specific models

8.6. Test each PROJECT_TYPE independently

8.7. Ensure core remains PROJECT_TYPE-agnostic (no imports from PROJECT_TYPE 
     apps)

Deliverable: PROJECT_TYPE-specific logic isolated in respective apps; core is 
             truly generic


TASK 9: Update Settings and Final Validation
---------------------------------------------
Goal: Configure settings, add all apps, and validate the refactor

Steps:
9.1. Update dev_app/settings/base.py INSTALLED_APPS:
     - Add all PROJECT_TYPE apps in order:
       'core',
       'general',
       'development',
       'construction',
       'precast',
       'pods',

9.2. Update TEMPLATES settings if needed:
     - Ensure APP_DIRS is True (default)
     - Verify template loaders find namespaced templates

9.3. Update STATICFILES_DIRS or STATICFILES_FINDERS if needed

9.4. Run Django checks:
     - python manage.py check
     - python manage.py check --deploy

9.5. Run makemigrations and migrate:
     - python manage.py makemigrations
     - python manage.py migrate

9.6. Run collectstatic:
     - python manage.py collectstatic --noinput

9.7. Run test suite:
     - python manage.py test

9.8. Manual testing:
     - Start dev server
     - Test each PROJECT_TYPE
     - Verify all SERVICEs work (quotes, invoices, etc.)
     - Check templates render correctly
     - Verify static assets load
     - Test PROJECT_TYPE switching

9.9. Update REPO_GUIDE.txt with any new conventions or commands

9.10. Commit final changes and push to refactor/domain-split branch

9.11. Open Draft PR to main with summary of changes

Deliverable: Fully functional modular app; all tests passing; ready for review


================================================================================
SUCCESS CRITERIA
================================================================================

1. All PROJECT_TYPE apps (core, general, development, construction, precast, 
   pods) exist with proper structure

2. All SERVICE modules (quotes, bills, pos, invoices, variations, suppliers, 
   order_book, documents) defined and business logic extracted

3. Views are thin controllers; business logic in SERVICEs

4. URL routing uses namespaces; no collisions

5. Templates and static assets namespaced; overrides work predictably

6. PROJECT_TYPE resolver implemented; request.project_type available

7. PROJECT_TYPE-specific logic isolated in respective apps

8. Core app is truly PROJECT_TYPE-agnostic

9. All Django checks pass

10. All tests pass

11. Manual testing confirms each PROJECT_TYPE works independently

12. Git history is clean with logical commits

13. Documentation (REPO_GUIDE.txt, refactor.txt) is up to date


================================================================================
NOTES & CONVENTIONS
================================================================================

- Use "move-only" commits when splitting files to preserve git blame
- Keep commits small and focused on one task
- Test after each task before moving to the next
- Update REPO_GUIDE.txt as new patterns emerge
- Use feature flags or settings to gate new behavior during migration
- Maintain backward compatibility where possible during transition
- Document any breaking changes or required data migrations
- Follow Django best practices and PEP 8 style guide
- Add docstrings and type hints to all new code
- Write tests for SERVICE modules (unit tests) and views (integration tests)


================================================================================
CURRENT STATUS
================================================================================

Branch: refactor/domain-split
Baseline Tag: ALL_IN_ONE_WORKING_VERSION

Completed:
- Renamed main/ to core/
- Updated settings, URLs, WSGI/ASGI to use core
- Applied initial migrations
- Created REPO_GUIDE.txt
- Server running successfully on port 8002

Next: Begin TASK 1 - Create App Structure for All PROJECT_TYPEs
