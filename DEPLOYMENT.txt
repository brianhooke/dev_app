===========================================
AWS ELASTIC BEANSTALK DEPLOYMENT GUIDE
Docker-based Deployment via AWS CLI
===========================================

CURRENT DEPLOYMENT STACK
------------------------
Platform: AWS Elastic Beanstalk with Docker (docker-compose)
Region: us-east-1 (N. Virginia)
Environment: dev-app-prod
URL: https://app.mason.build

Components:
- Application: Django 5.0.6 in Docker container
- Database: SQLite (local to container)
- Static/Media: Local filesystem
- Load Balancer: Application Load Balancer with HTTPS
- DNS: Route 53 with app.mason.build CNAME

DEPLOYMENT PROCESS
------------------
1. Make code changes locally

2. Increment version number in dashboard:
   Update the version number in core/templates/core/dashboard.html
   (e.g., v31 → v32)

3. Commit to git:
   git add .
   git commit -m "your changes"

4. Deploy to AWS using AWS CLI:
   zip -r deploy.zip . -x "*.git*" "*__pycache__*" "*.pyc" ".venv/*" "*.sqlite3" ".DS_Store" "*.log" "csv/*" "pdfs/*" ".elasticbeanstalk/*" "venv/*" "media/*" && \
   aws s3 cp deploy.zip s3://elasticbeanstalk-us-east-1-629256540295/dev-app/deploy-vXX-description.zip && \
   aws elasticbeanstalk create-application-version \
     --application-name dev-app \
     --version-label vXX-description \
     --source-bundle S3Bucket="elasticbeanstalk-us-east-1-629256540295",S3Key="dev-app/deploy-vXX-description.zip" && \
   aws elasticbeanstalk update-environment \
     --environment-name dev-app-prod \
     --version-label vXX-description

   Note: Replace XX with next version number and description with brief change summary

That's it! Deployment takes 5-10 minutes.

WHAT HAPPENS DURING DEPLOYMENT
-------------------------------
1. Local code is zipped (excluding .git, __pycache__, venv, etc.)
2. Zip file is uploaded to S3 bucket
3. EB creates new application version from S3 zip
4. EB updates environment to use new version
5. Docker image is built on AWS using Dockerfile
6. Container starts using docker-compose.yml
7. Startup script (start.sh) runs:
   - Runs database migrations automatically
   - Collects static files
   - Starts gunicorn with Django on port 80
8. Load balancer switches traffic to new container
9. Old container is terminated

DEPLOYMENT FEATURES
-------------------
✓ Zero-downtime deployments (old version runs until new one is healthy)
✓ Automatic rollback if deployment fails
✓ Automatic database migrations on startup
✓ Version control via numbered releases (v39, v40, etc.)
✓ Direct AWS CLI control without eb CLI dependency

IMPORTANT NOTES
---------------
- GitHub is NOT involved in deployment (deploys from local code)
- Always commit changes to git before deploying
- Increment version number for each deployment (v39, v40, v41, etc.)
- Use descriptive version labels (e.g., v39-contacts-update)
- Migrations run automatically on every deployment
- Container restarts on every deployment
- SQLite database is local to container (data persists via volume mount)

USEFUL AWS CLI COMMANDS
-----------------------
# Check environment status
aws elasticbeanstalk describe-environments --environment-names dev-app-prod

# View recent events
aws elasticbeanstalk describe-events --environment-name dev-app-prod --max-items 20

# List application versions
aws elasticbeanstalk describe-application-versions --application-name dev-app

# View environment health
aws elasticbeanstalk describe-environment-health --environment-name dev-app-prod --attribute-names All

ENVIRONMENT VARIABLES
---------------------
Currently set via AWS EB Console or AWS CLI

Settings Module:
- DJANGO_SETTINGS_MODULE=dev_app.settings.local (uses SQLite)

Required variables:
- SECRET_KEY
- PROJECT_NAME

Optional variables:
- EMAIL_HOST_USER, EMAIL_HOST_PASSWORD, EMAIL_CC, DEFAULT_FROM_EMAIL
- LETTERHEAD_PATH, BACKGROUND_IMAGE_PATH
- XERO_CLIENT_ID, XERO_CLIENT_SECRET, XERO_ENCRYPTION_KEY

KEY FILES FOR DEPLOYMENT
------------------------
Dockerfile              - Defines the Docker image (Python 3.11, dependencies)
docker-compose.yml      - Defines how container runs (port 80, env vars)
start.sh               - Startup script (collectstatic, migrate, gunicorn)
requirements.txt       - Python dependencies
.dockerignore          - Files to exclude from Docker build
.ebignore              - Files to exclude from EB deployment (if exists)

DOCKER APPROACH BENEFITS
------------------------
✓ Full control over system dependencies (PDF libraries, PostgreSQL client, etc.)
✓ Consistent environment (same container locally and in production)
✓ Easier debugging (can test exact container before deploying)
✓ Avoids platform-specific issues (native Python platform kept failing)

DEVELOPMENT WORKFLOW
--------------------
During development:
- Work locally with migrations as normal
- Test with fake data
- Deploy to AWS dev environment frequently
- Migration history can be messy

Before production launch:
1. Delete all migration files: find . -path "*/migrations/*.py" -not -name "__init__.py" -delete
2. Create fresh initial migration: python manage.py makemigrations
3. Create new production database
4. Deploy with clean migration history

After production launch:
- Keep ALL migrations (never delete them)
- Create incremental migrations for schema changes
- Test migrations on staging before production

COST CONSIDERATIONS
-------------------
Current resources:
- EC2 instance (t3.small or similar): ~$15/month
- S3 storage (for deployment zips): ~$1/month
- Load Balancer: ~$16/month
- Data transfer: Variable

Total: ~$30-40/month for this setup

Can be optimized by:
- Using smaller instance types
- Terminating environment when not in use
- Using reserved instances for production

TROUBLESHOOTING
---------------
If deployment fails:
1. Check AWS EB console for deployment errors
2. View recent events: aws elasticbeanstalk describe-events --environment-name dev-app-prod
3. Verify environment variables are set in EB console
4. Check that S3 bucket exists and is accessible
5. Verify Docker build completes successfully

If app shows errors:
1. Check logs via AWS EB console or CloudWatch
2. Verify DJANGO_SETTINGS_MODULE is set to dev_app.settings.local
3. Check that migrations ran successfully in startup logs
4. Verify all required environment variables are set

If static files don't load:
1. Check that collectstatic ran successfully in startup logs
2. Verify STATIC_ROOT and STATIC_URL in settings
3. Check file permissions in container

FUTURE IMPROVEMENTS (OPTIONAL)
------------------------------
- Set up CI/CD with GitHub Actions for automated deployments
- Add CloudWatch monitoring and alerts
- Create staging environment
- Migrate to RDS PostgreSQL for production data persistence
- Add health check endpoint
- Configure auto-scaling rules
- Implement blue-green deployments

RELATED FILES
-------------
AWS_DEPLOYMENT_GUIDE.md - Detailed AWS setup documentation
local.py               - Settings file used in production (SQLite)
base.py                - Base Django settings
production_aws.py      - AWS-specific settings (RDS PostgreSQL - not currently used)

TRANSFERRING DATA TO AWS
------------------------
Since AWS uses SQLite (local to container), you can transfer data using management commands:

Export data locally:
   python manage.py export_xero_instances --output xero_instances_export.json

Deploy to AWS (includes the export file):
   [Use the standard deployment command above]

Import data on AWS (via SSH or AWS Systems Manager):
   # SSH into EC2 instance
   ssh -i your-key.pem ec2-user@[instance-ip]
   
   # Navigate to app directory
   cd /var/app/current
   
   # Activate virtual environment
   source /var/app/venv/*/bin/activate
   
   # Run import command
   python manage.py import_xero_instances --input xero_instances_export.json
   
   # Or use --update flag to overwrite existing records
   python manage.py import_xero_instances --input xero_instances_export.json --update

Alternative: Use AWS Systems Manager Session Manager (no SSH key needed)
   1. Go to AWS Systems Manager Console
   2. Click "Session Manager" → "Start session"
   3. Select your EC2 instance
   4. Run the same commands as above

Note: Xero credentials are encrypted using XERO_ENCRYPTION_KEY from settings.
Ensure the same encryption key is set on both local and AWS environments.

XERO DATA PERSISTENCE
---------------------
The Xero credentials are stored in SQLite which can be reset on deployment.
To persist Xero data across deployments:

1. BACKUP (from AWS - do this BEFORE deploying if Xero is working):
   - SSH/SSM into the EC2 instance
   - Run: docker exec $(docker ps -q) python manage.py export_xero_b64
   - Copy the base64 output

2. SET ENVIRONMENT VARIABLE:
   aws elasticbeanstalk update-environment \
       --environment-name dev-app-prod \
       --option-settings Namespace=aws:elasticbeanstalk:application:environment,OptionName=XERO_DATA,Value='<base64_string>'

3. AUTOMATIC RESTORE:
   - On startup, start.sh runs: python manage.py import_xero_from_env
   - This imports Xero data from XERO_DATA environment variable
   - Data is automatically restored on every deployment

IMPORTANT: The XERO_DATA env var contains encrypted credentials.
The XERO_ENCRYPTION_KEY must be the same on AWS as when the data was exported.

DEPLOYMENT HISTORY
------------------
Recent deployments:
- v104-construction-po-columns: Construction PO PDF shows 6 columns (Description/Units/Qty/Rate/Amount/Quote#) instead of 3
- v103-construction-allocations: Fix unit display (use Costing.unit), column alignment for allocated tables, category optgroups in quote allocation dropdowns
- v94-projects-card-grid: Projects card grid layout with modal edit/create, tender/execution navigation preserved
- v78-s3-media: Use S3 for media file storage in Docker/AWS to persist uploads across deployments
- v77-cleanup: Remove spaceship/alien animations, change SHIFT+B to SHIFT+BIN for DB wipe
- v76-po-edit-claim: Add Edit Claim/Cancel buttons, bidirectional %/$ input, comparison email on approval with adjustments
- v70-po-url-fix: Fix PO URL generation for AWS (use request host instead of hardcoded URL) + Add Pull Contacts/Accounts buttons to Xero table
- v63-xero-persistence: Auto-restore Xero data from XERO_DATA env var on startup
- v62-fix-environ: Added django-environ to requirements.txt
- v61-po-public-improvements: PO Public URL expandable claims, document viewer buttons
- v40-xero-import: Added Xero instances export/import management commands
- v39-contacts-update: Added Xero contacts update functionality (BSB, Account, ABN, Email)
- v38-sqlite: Switched to SQLite database
- v37-subdomain: Simplified URLs for app.mason.build subdomain

SUPPORT & DOCUMENTATION
-----------------------
AWS EB Documentation: https://docs.aws.amazon.com/elasticbeanstalk/
AWS CLI EB Reference: https://docs.aws.amazon.com/cli/latest/reference/elasticbeanstalk/
Docker Documentation: https://docs.docker.com/
Django Deployment: https://docs.djangoproject.com/en/5.0/howto/deployment/

Last Updated: 2025-12-01
