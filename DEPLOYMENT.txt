===========================================
AWS ELASTIC BEANSTALK DEPLOYMENT GUIDE
Docker-based Deployment via AWS CLI
===========================================

CURRENT DEPLOYMENT STACK
------------------------
Platform: AWS Elastic Beanstalk with Docker (docker-compose)
Region: us-east-1 (N. Virginia)
Environment: dev-app-prod
URL: https://app.mason.build

Components:
- Application: Django 5.0.6 in Docker container
- Database: AWS RDS PostgreSQL (production)
- Static Files: Local filesystem (baked into Docker image)
- Media Files: AWS S3 (dev-app-mason-bucket)
- Load Balancer: Application Load Balancer with HTTPS
- DNS: Route 53 with app.mason.build CNAME

DEPLOYMENT PROCESS
------------------
1. Make code changes locally

2. Increment version number in dashboard:
   Update the version number in core/templates/core/dashboard.html
   (e.g., v31 → v32)

3. Commit to git:
   git add .
   git commit -m "your changes"

4. Deploy to AWS using AWS CLI:
   zip -r deploy.zip . -x "*.git*" "*__pycache__*" "*.pyc" ".venv/*" "*.sqlite3" ".DS_Store" "*.log" "csv/*" "pdfs/*" ".elasticbeanstalk/*" "venv/*" "media/*" && \
   aws s3 cp deploy.zip s3://elasticbeanstalk-us-east-1-629256540295/dev-app/deploy-vXX-description.zip && \
   aws elasticbeanstalk create-application-version \
     --application-name dev-app \
     --version-label vXX-description \
     --source-bundle S3Bucket="elasticbeanstalk-us-east-1-629256540295",S3Key="dev-app/deploy-vXX-description.zip" && \
   aws elasticbeanstalk update-environment \
     --environment-name dev-app-prod \
     --version-label vXX-description

   Note: Replace XX with next version number and description with brief change summary

That's it! Deployment takes 5-10 minutes.

WHAT HAPPENS DURING DEPLOYMENT
-------------------------------
1. Local code is zipped (excluding .git, __pycache__, venv, etc.)
2. Zip file is uploaded to S3 bucket
3. EB creates new application version from S3 zip
4. EB updates environment to use new version
5. Docker image is built on AWS using Dockerfile
6. Container starts using docker-compose.yml
7. Startup script (start.sh) runs:
   - Runs database migrations automatically
   - Collects static files to local filesystem
   - Starts gunicorn with Django on port 80

8. Environment variables are loaded from .env file (created by .ebextensions)
9. Load balancer switches traffic to new container
10. Old container is terminated

DEPLOYMENT FEATURES
-------------------
✓ Zero-downtime deployments (old version runs until new one is healthy)
✓ Automatic rollback if deployment fails
✓ Automatic database migrations on startup
✓ Version control via numbered releases (v39, v40, etc.)
✓ Direct AWS CLI control without eb CLI dependency

IMPORTANT NOTES
---------------
- GitHub is NOT involved in deployment (deploys from local code)
- Always commit changes to git before deploying
- Increment version number for each deployment (v127, v128, v129, etc.)
- Use descriptive version labels (e.g., v128-env-var-fix)
- Migrations run automatically on every deployment
- Container restarts on every deployment
- RDS PostgreSQL database persists across deployments
- S3 media files persist across deployments
- Environment variables are passed via .env file (see .ebextensions/04_docker_env.config)

USEFUL AWS CLI COMMANDS
-----------------------
# Check environment status
aws elasticbeanstalk describe-environments --environment-names dev-app-prod

# View recent events
aws elasticbeanstalk describe-events --environment-name dev-app-prod --max-items 20

# List application versions
aws elasticbeanstalk describe-application-versions --application-name dev-app

# View environment health
aws elasticbeanstalk describe-environment-health --environment-name dev-app-prod --attribute-names All

ENVIRONMENT VARIABLES
---------------------
Set via AWS EB Console → Configuration → Environment properties

Settings Module:
- DJANGO_SETTINGS_MODULE=dev_app.settings.production_aws (uses RDS PostgreSQL + S3)

Required RDS Variables:
- RDS_HOSTNAME - RDS PostgreSQL endpoint
- RDS_DB_NAME - Database name
- RDS_USERNAME - Database username
- RDS_PASSWORD - Database password
- RDS_PORT - Database port (5432)

Required AWS S3 Variables:
- AWS_STORAGE_BUCKET_NAME - S3 bucket for media files
- AWS_ACCESS_KEY_ID - AWS access key
- AWS_SECRET_ACCESS_KEY - AWS secret key
- AWS_S3_REGION_NAME - AWS region (us-east-1)

Other Required Variables:
- SECRET_KEY - Django secret key
- PROJECT_NAME - Project name

Optional Variables:
- EMAIL_HOST_USER, EMAIL_HOST_PASSWORD, EMAIL_CC, DEFAULT_FROM_EMAIL
- LETTERHEAD_PATH, BACKGROUND_IMAGE_PATH
- XERO_DATA, XERO_ENCRYPTION_KEY

IMPORTANT: Environment variables are passed to Docker container via .env file
(see .ebextensions/04_docker_env.config for implementation)

Note: Xero credentials are now stored in AWS SSM Parameter Store, not environment variables.

KEY FILES FOR DEPLOYMENT
------------------------
Dockerfile              - Defines the Docker image (Python 3.11, dependencies)
docker-compose.yml      - Defines how container runs (port 80, env_file)
start.sh               - Startup script (collectstatic, migrate, gunicorn)
requirements.txt       - Python dependencies
.dockerignore          - Files to exclude from Docker build
.ebignore              - Files to exclude from EB deployment (if exists)
.ebextensions/         - EB configuration files
├── 01_timeout.config  - Deployment timeout settings
├── 02_db_volume.config - Database volume persistence
└── 04_docker_env.config - Creates .env file from EB environment variables

DOCKER APPROACH BENEFITS
------------------------
✓ Full control over system dependencies (PDF libraries, PostgreSQL client, etc.)
✓ Consistent environment (same container locally and in production)
✓ Easier debugging (can test exact container before deploying)
✓ Avoids platform-specific issues (native Python platform kept failing)

DEVELOPMENT WORKFLOW
--------------------
During development:
- Work locally with migrations as normal
- Test with fake data
- Deploy to AWS dev environment frequently
- Migration history can be messy

Before production launch:
1. Delete all migration files: find . -path "*/migrations/*.py" -not -name "__init__.py" -delete
2. Create fresh initial migration: python manage.py makemigrations
3. Create new production database
4. Deploy with clean migration history

After production launch:
- Keep ALL migrations (never delete them)
- Create incremental migrations for schema changes
- Test migrations on staging before production

COST CONSIDERATIONS
-------------------
Current resources:
- EC2 instance (t3.small or similar): ~$15/month
- S3 storage (for deployment zips): ~$1/month
- Load Balancer: ~$16/month
- Data transfer: Variable

Total: ~$30-40/month for this setup

Can be optimized by:
- Using smaller instance types
- Terminating environment when not in use
- Using reserved instances for production

TROUBLESHOOTING
---------------
If deployment fails:
1. Check AWS EB console for deployment errors
2. View recent events: aws elasticbeanstalk describe-events --environment-name dev-app-prod
3. Verify environment variables are set in EB console
4. Check that S3 bucket exists and is accessible
5. Verify Docker build completes successfully

If app shows errors:
1. Check logs via AWS EB console or CloudWatch
2. Verify DJANGO_SETTINGS_MODULE is set to dev_app.settings.production_aws
3. Check that RDS environment variables are set and reaching container (check start.sh logs)
4. Check that migrations ran successfully in startup logs
5. Verify all required environment variables are set in EB Console
6. Check .ebextensions/04_docker_env.config logs for .env file creation

If static files don't load:
1. Check that collectstatic ran successfully in startup logs
2. Verify STATIC_ROOT and STATIC_URL in settings
3. Check file permissions in container

FUTURE IMPROVEMENTS (OPTIONAL)
------------------------------
- Set up CI/CD with GitHub Actions for automated deployments
- Add CloudWatch monitoring and alerts
- Create staging environment
✅ Migrated to RDS PostgreSQL for production data persistence
- Add health check endpoint
- Configure auto-scaling rules
- Implement blue-green deployments

RELATED FILES
-------------
AWS_DEPLOYMENT_GUIDE.md - Detailed AWS setup documentation
local.py               - Settings file for local development (SQLite fallback)
base.py                - Base Django settings
production_aws.py      - AWS-specific settings (RDS PostgreSQL + S3 - CURRENTLY USED)
.ebextensions/         - Elastic Beanstalk configuration files

XERO DATA PERSISTENCE (AWS SSM PARAMETER STORE)
------------------------------------------------
Xero credentials are now stored in AWS SSM Parameter Store instead of the database.
This ensures credentials persist across database wipes and deployments automatically.

HOW IT WORKS:
- When you set up a Xero connection via xero.html, credentials are stored in SSM
- Parameters are stored at: /dev-app/xero/{instance_pk}/{param_name}
- Parameters stored: client_id, client_secret, access_token, refresh_token, tenant_id, token_expires_at
- All parameters are stored as SecureString (encrypted at rest)
- Falls back to encrypted DB fields for local development without AWS credentials

REQUIRED IAM PERMISSIONS:
The EC2 instance role needs these SSM permissions:
- ssm:GetParameter
- ssm:PutParameter
- ssm:DeleteParameter
- ssm:DescribeParameters

Resource ARN: arn:aws:ssm:us-east-1:*:parameter/dev-app/xero/*

NO MANUAL STEPS REQUIRED:
- Credentials are automatically saved to SSM when you authorize Xero
- Credentials persist across deployments and DB wipes
- No need to export/import or set environment variables

VIEWING SSM PARAMETERS (optional):
aws ssm get-parameters-by-path --path "/dev-app/xero" --recursive --with-decryption

DEPLOYMENT HISTORY
------------------
Recent deployments:
- v129: Trivial deployment to test S3 media file persistence
- v128: ✅ FIXED - Environment variable passing to Docker container using .env file and ebextensions
- v127: Test deployment with all environment variables configured in AWS
- v126: Rollback to v112 codebase (last known stable version)
- v125: Rollback to v120 configuration
- v123: Attempted predeploy hook to create .env file (failed - EB env file path incorrect)
- v122: Fixed middleware to return 400 for DisallowedHost exceptions
- v121: Added env var debugging to diagnose RDS connection issue
- v120: Fixed production_aws to use local static files + S3 for media only
- v119: Fixed ELB health check failures - handle internal IP hosts in middleware
- v118: Added S3 diagnostic logging to documents endpoints
- v117: Added debug-settings endpoint to check current settings
- v116: Simplified logging to avoid 500 errors
- v115: Added comprehensive logging for S3 upload debugging
- v114: Fixed start.sh to default to production_aws settings
- v113: Test S3 persistence across deployments
- v112: Fix project navigation polling for AJAX-loaded projects list (LAST STABLE)

CRITICAL FIX (v128):
- Issue: RDS environment variables not reaching Docker container
- Solution: .ebextensions/04_docker_env.config creates .env file from EB env vars
- Result: Django now connects to RDS PostgreSQL instead of local socket

SUPPORT & DOCUMENTATION
-----------------------
AWS EB Documentation: https://docs.aws.amazon.com/elasticbeanstalk/
AWS CLI EB Reference: https://docs.aws.amazon.com/cli/latest/reference/elasticbeanstalk/
Docker Documentation: https://docs.docker.com/
Django Deployment: https://docs.djangoproject.com/en/5.0/howto/deployment/

Last Updated: 2026-01-03
